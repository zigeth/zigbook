#!/usr/bin/env node

import { promises as fs } from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const ROOT = path.resolve(__dirname, '..')
const STD_DIR = path.join(ROOT, 'std')
const CONTENT_ROOT = path.join(ROOT, 'content', 'docs', 'std')

const CATEGORIES_FILE = path.join(ROOT, 'data', 'std-categories.json')
const NAVIGATION_FILE = path.join(ROOT, 'data', 'std-navigation.json')

const humanize = (value) => {
    const noExt = value.replace(/\.md$/, '')
    const snakeToSpace = noExt.replace(/_/g, ' ')
    const withSpaces = snakeToSpace.replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    return withSpaces
        .split(' ')
        .filter(Boolean)
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ')
}

const toSlug = (value) => {
    const base = value.replace(/\.md$/, '')
    return base
        .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
        .replace(/_/g, '-')
        .toLowerCase()
}

const quote = (value) => `"${value.replace(/"/g, '\\"')}"`

const stripTopMatter = (content) => {
    const lines = content.split(/\r?\n/)
    if (lines[0]?.startsWith('#')) {
        lines.shift()
    }
    while (lines[0]?.trim() === '') {
        lines.shift()
    }
    const cleaned = []
    for (const line of lines) {
        if (line.trim() === '[← Back to index](index.md)' || line.trim() === '[<- Back to index](index.md)') {
            continue
        }
        cleaned.push(line)
    }
    return cleaned.join('\n').trimStart()
}

const ensureDir = async (dir) => {
    await fs.mkdir(dir, { recursive: true })
}

const writeFile = async (filePath, contents) => {
    await ensureDir(path.dirname(filePath))
    await fs.writeFile(filePath, contents, 'utf8')
}

const buildModuleFrontMatter = (meta) => {
    const { moduleTitle, navTitle, category, tags, sourcePath, lastUpdated, description } = meta
    return [
        '---',
        `title: ${quote(moduleTitle)}`,
        `description: ${quote(description)}`,
        'navigation:',
        `  title: ${quote(navTitle)}`,
        `  icon: ${category.icon}`,
        `  badge: ${quote(category.badge)}`,
        `badge: ${quote(category.badge)}`,
        `category: ${quote(category.key)}`,
        'tags:',
        ...tags.map((tag) => `  - ${quote(tag)}`),
        `source: ${quote(sourcePath)}`,
        `githubPath: ${quote(sourcePath)}`,
        `lastUpdated: ${quote(lastUpdated)}`,
        'seo:',
        `  title: ${quote(`${moduleTitle} · Zig 0.15.1 standard library reference`)}`,
        `  description: ${quote(description)}`,
        '---',
        ''
    ].join('\n')
}

const buildCallout = (sourcePath) => `::callout{type="info" icon="i-lucide-book-open-check"}
This page syncs automatically from Zig's source: \`${sourcePath}\`.
::

`

const buildCategoryDirFile = (category, order) => {
    return [
        `title: ${quote(category.label)}`,
        'navigation:',
        `  title: ${quote(category.navTitle)}`,
        `  icon: ${category.icon}`,
        `  order: ${order + 1}`,
        `description: ${quote(category.description)}`,
        ''
    ].join('\n')
}

const buildCategoryDirMarkdown = (category) => {
    return [
        '---',
        `title: ${quote(category.label)}`,
        `description: ${quote(category.description)}`,
        '---',
        '',
        `# ${category.label}`,
        '',
        `${category.description}`,
        '',
        'This autogenerated directory entry keeps the `/raw/docs/std/.../_dir.md` endpoint healthy and signals that modules in this folder stay in sync with the upstream standard library sources.',
        ''
    ].join('\n')
}

const buildCategoryIndex = (category, modulesMeta) => {
    const items = modulesMeta
        .map((item) => `- [${item.navTitle}](/docs/std/${category.key}/${item.slug}) — ${item.description}`)
        .join('\n')

    return [
        '---',
        `title: ${quote(category.label)}`,
        `description: ${quote(category.description)}`,
        'navigation:',
        '  title: "Overview"',
        'seo:',
        `  title: ${quote(`${category.label} · Zig 0.15.1 standard library reference`)}`,
        `  description: ${quote(category.description)}`,
        '---',
        '',
        `${category.description}`,
        '',
        '## Modules',
        '',
        items,
        ''
    ].join('\n')
}

const buildRootDirFile = () => {
    return [
        'title: "Standard Library"',
        'navigation:',
        '  title: "Standard Library"',
        '  icon: i-lucide-library',
        '  order: 3',
        'description: "Zig 0.15.1 standard library reference grouped by domain."',
        ''
    ].join('\n')
}

const buildRootDirMarkdown = () => {
    return [
        '---',
        'title: "Standard Library"',
        'description: "Zig 0.15.1 standard library reference grouped by domain."',
        '---',
        '',
        '# Zig Standard Library Reference',
        '',
        'This directory holds the synchronized Zig 0.15.1 standard library documentation organised by domain. Use the category landing pages to browse into individual module references.',
        ''
    ].join('\n')
}

const buildRootIndex = () => {
    return [
        '---',
        'title: "Zig 0.15.1 Standard Library"',
        'description: "Explore the Zig standard library modules grouped by domain and kept in sync with the upstream documentation."',
        'navigation:',
        '  title: "Overview"',
        'seo:',
        '  title: "Zig 0.15.1 Standard Library · Zigbook"',
        '  description: "Explore curated categories for the Zig 0.15.1 standard library reference."',
        '---',
        '',
        '::u-page-section',
        '#title',
        'Zig 0.15.1 standard library reference',
        '',
        '#description',
        'The Zigbook documentation syncs the upstream standard library references and groups them by domain for faster discovery. Pick a category card to deep dive into the modules you need.',
        '',
        '::note',
        'Keep the catalog current by running `npm run sync:std` after updating any Markdown sources under `std/`.',
        '::',
        '::',
        '',
        '<ReferenceCategoryShowcase class="mt-12" />',
        ''
    ].join('\n')
}

async function loadCategories() {
    const raw = await fs.readFile(CATEGORIES_FILE, 'utf8')
    return JSON.parse(raw)
}

async function main() {
    const categories = await loadCategories()
    const categoryMap = new Map()
    for (const category of categories) {
        for (const moduleName of category.modules) {
            if (categoryMap.has(moduleName)) {
                throw new Error(`Module "${moduleName}" is assigned to multiple categories`)
            }
            categoryMap.set(moduleName, category)
        }
    }

    await ensureDir(CONTENT_ROOT)
    await writeFile(path.join(CONTENT_ROOT, '_dir.yml'), buildRootDirFile())
    await writeFile(path.join(CONTENT_ROOT, '_dir.md'), buildRootDirMarkdown())

    const stdEntries = await fs.readdir(STD_DIR)
    const moduleFiles = stdEntries.filter((file) => file.endsWith('.md') && file !== 'index.md')

    const categoryData = new Map(categories.map((cat) => [cat.key, []]))

    for (const category of categories) {
        const categoryDir = path.join(CONTENT_ROOT, category.key)
        await ensureDir(categoryDir)
        await writeFile(
            path.join(categoryDir, '_dir.yml'),
            buildCategoryDirFile(category, categories.indexOf(category))
        )
        await writeFile(
            path.join(categoryDir, '_dir.md'),
            buildCategoryDirMarkdown(category)
        )
    }

    for (const fileName of moduleFiles) {
        const moduleKey = fileName.replace(/\.md$/, '')
        const category = categoryMap.get(moduleKey)
        if (!category) {
            throw new Error(`Module "${moduleKey}" is missing a category assignment.`)
        }

        const filePath = path.join(STD_DIR, fileName)
        const raw = await fs.readFile(filePath, 'utf8')
        const stat = await fs.stat(filePath)

        const moduleTitleMatch = raw.match(/^#\s+(.+)$/m)
        const moduleTitle = moduleTitleMatch ? moduleTitleMatch[1].trim() : `std.${moduleKey.replace(/_/g, '.')}`
        const navTitle = humanize(moduleKey)
        const slug = toSlug(fileName)
        const description = `Comprehensive reference for Zig's ${moduleTitle} module covering ${category.descriptor}.`

        const moduleMeta = {
            moduleKey,
            moduleTitle,
            navTitle,
            slug,
            category,
            tags: ['zig', 'standard-library', category.key],
            sourcePath: `std/${fileName}`,
            lastUpdated: stat.mtime.toISOString(),
            description
        }

        const frontMatter = buildModuleFrontMatter(moduleMeta)
        const callout = buildCallout(moduleMeta.sourcePath)
        const body = stripTopMatter(raw)

        const outPath = path.join(CONTENT_ROOT, category.key, `${slug}.md`)
        await writeFile(outPath, `${frontMatter}${callout}${body}\n`)

        categoryData.get(category.key).push(moduleMeta)
    }

    for (const category of categories) {
        const modulesMeta = categoryData.get(category.key).sort((a, b) => a.navTitle.localeCompare(b.navTitle))
        const indexPath = path.join(CONTENT_ROOT, category.key, 'index.md')
        await writeFile(indexPath, buildCategoryIndex(category, modulesMeta))
    }

    await writeFile(path.join(CONTENT_ROOT, 'index.md'), buildRootIndex())

    const navigationPayload = categories.map((category) => {
        const modules = (categoryData.get(category.key) || []).map((meta) => ({
            key: meta.moduleKey,
            title: meta.moduleTitle,
            navTitle: meta.navTitle,
            slug: meta.slug,
            description: meta.description,
            path: `/docs/std/${category.key}/${meta.slug}`,
            source: meta.sourcePath,
            lastUpdated: meta.lastUpdated,
        }))

        return {
            key: category.key,
            label: category.label,
            navTitle: category.navTitle,
            badge: category.badge,
            icon: category.icon,
            description: category.description,
            path: `/docs/std/${category.key}/`,
            modules,
        }
    })

    await writeFile(NAVIGATION_FILE, `${JSON.stringify(navigationPayload, null, 2)}\n`)
}

main().catch((error) => {
    console.error(error)
    process.exitCode = 1
})
